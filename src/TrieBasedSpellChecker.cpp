//
// Created by Olcay Taner YILDIZ on 7.03.2023.
//

#include "TrieBasedSpellChecker.h"
#include "TrieCandidate.h"

/**
 * A constructor of {@link TrieBasedSpellChecker} class which takes a {@link FsmMorphologicalAnalyzer}, an {@link NGram}
 * and a {@link SpellCheckerParameter} as inputs. Then, calls its super class {@link NGramSpellChecker} with given inputs.
 *
 * @param fsm       {@link FsmMorphologicalAnalyzer} type input.
 * @param nGram     {@link NGram} type input.
 * @param parameter {@link SpellCheckerParameter} type input.
 */
TrieBasedSpellChecker::TrieBasedSpellChecker(const FsmMorphologicalAnalyzer &fsm, NGram<string> *nGram,
                                             const SpellCheckerParameter &_parameter) : NGramSpellChecker(fsm, nGram,
                                                                                                          _parameter) {
    loadTrieDictionaries();
    prepareTrie();
}

/**
 * {@inheritDoc}
 * This method also loads generated words from a file.
 */
void TrieBasedSpellChecker::loadTrieDictionaries() {
    ifstream inputStream;
    inputStream.open("generated_words.txt", ifstream::in);
    string line;
    while (inputStream.good()) {
        getline(inputStream, line);
        generatedWords.emplace_back(line);
    }
    inputStream.close();
}

/**
 * Populates a Trie data structure with a set of strings generated by the morphological analyzer.
 *
 * @see Trie
 * @see FsmMorphologicalAnalyzer#generateAllParses(TxtWord, int)
 */
void TrieBasedSpellChecker::prepareTrie() {
    trie = new SpellCheckerTrie();
    for (auto &word: generatedWords) {
        trie->insert(word);
    }
}

/**
 * The candidateList method takes a {@link Word} as an input and creates a candidates {@link ArrayList} by calling generateCandidateList
 * method with given word. Then, it loops i times where i ranges from 0 to size of candidates {@link ArrayList} and creates a
 * {@link FsmParseList} by calling morphologicalAnalysis with each item of candidates {@link ArrayList}. If the size of
 * {@link FsmParseList} is 0, it then removes the ith item.
 *
 * @param word Word input.
 * @return candidates {@link ArrayList}.
 */
vector<Candidate *> TrieBasedSpellChecker::candidateList(Word *word, Sentence *sentence) {
    TrieCandidate *candidate;
    deque<TrieCandidate *> candidates;
    vector<Candidate *> results;
    candidates.push_front(new TrieCandidate(word->getName(), -1, 0));
    string candidateName;
    double penaltyLimit = min(word->charCount() / 2.0, 3.0);
    while (!candidates.empty()) {
        candidate = candidates.front();
        candidateName = candidate->getName();
        if (trie->search(candidateName)) {
            int itemIndex = searchCandidates(results, candidate);
            if (itemIndex != -1 && ((TrieCandidate*) results[itemIndex])->getCurrentPenalty() <= candidate->getCurrentPenalty()) {
                candidates.pop_front();
            } else {
                results.emplace_back(candidate);
                candidates.pop_front();
            }
        } else {
            if (candidate->getCurrentPenalty() > penaltyLimit - 1 ||
                candidate->getCurrentIndex() >= Word::size(candidateName) - 1) {
                candidates.pop_front();
            } else {
                candidate = candidates.front();
                candidate->nextIndex();
                candidates.push_back(new TrieCandidate(candidate->getName(), candidate->getCurrentIndex(),
                                                       candidate->getCurrentPenalty()));
                candidate = candidates.front();
                vector<TrieCandidate *> newCandidates = generateTrieCandidates(candidate);
                candidates.pop_front();
                candidates.insert(candidates.end(), newCandidates.begin(), newCandidates.end());
            }
        }
    }
    return results;
}

vector<TrieCandidate *> TrieBasedSpellChecker::generateTrieCandidates(TrieCandidate *candidate) {
    vector<TrieCandidate *> candidates;
    string currentName = candidate->getName();
    string deasciifiedWord;
    int currentIndex = candidate->getCurrentIndex();
    double currentPenalty = candidate->getCurrentPenalty();
    string letters;
    SpellCheckerTrieNode* currentNode = trie->getTrieNode(Word::substring(currentName, 0, currentIndex));
    if (currentNode == nullptr) {
        return candidates;
    }
    letters = currentNode->childrenToString();
    string ch = Word::charAt(currentName, currentIndex);
    string ch2;
    if (ch == "c") {
        ch2 = "ç";
    } else {
        if (ch == "g") {
            ch2 = "ğ";
        } else {
            if (ch == "i") {
                ch2 = "ı";
            } else {
                if (ch == "s") {
                    ch2 = "ş";
                } else {
                    if (ch == "o") {
                        ch2 = "ö";
                    } else {
                        if (ch == "u") {
                            ch2 = "ü";
                        }
                    }
                }
            }
        }
    }
    if (!ch2.empty()){
        deasciifiedWord =
                Word::substring(currentName, 0, currentIndex - 1) + ch2 + Word::substring(currentName, currentIndex + 1);
    } else {
        deasciifiedWord = currentName;
    }
    if (deasciifiedWord != currentName && trie->startsWith(Word::substring(deasciifiedWord, 0, currentIndex + 1))) {
        candidates.emplace_back(new TrieCandidate(deasciifiedWord, currentIndex, currentPenalty + 0.2));
    }
    for (int j = 0; j < Word::size(letters); j++) {
        string replaced = Word::substring(currentName, 0, currentIndex) + Word::charAt(letters, j) +
                          Word::substring(currentName, currentIndex + 1);
        if (trie->startsWith(Word::substring(replaced, 0, currentIndex + 1))) {
            candidates.emplace_back(new TrieCandidate(replaced, currentIndex, currentPenalty + 1));
        }
        string added = Word::substring(currentName, 0, currentIndex) + Word::charAt(letters, j) +
                       Word::substring(currentName, currentIndex);
        if (trie->startsWith(Word::substring(added, 0, currentIndex + 1))) {
            candidates.emplace_back(new TrieCandidate(added, currentIndex, currentPenalty + 1));
        }
        string addedLast = currentName + Word::charAt(letters, j);
        if (trie->startsWith(addedLast)) {
            candidates.emplace_back(new TrieCandidate(addedLast, currentIndex, currentPenalty + 1));
        }
    }
    string deleted = Word::substring(currentName, 0, currentIndex) + Word::substring(currentName, currentIndex + 1);
    if (deleted.length() > 1 && trie->startsWith(Word::substring(deleted, 0, currentIndex))) {
        candidates.emplace_back(new TrieCandidate(deleted, currentIndex - 1, currentPenalty + 1));
    }
    if (currentIndex < Word::size(currentName) - 1 &&
        Word::charAt(currentName, currentIndex) != Word::charAt(currentName, currentIndex + 1) &&
        trie->startsWith(Word::substring(currentName, 0, currentIndex + 2))) {
        string swapped = Word::substring(currentName, 0, currentIndex) + Word::charAt(currentName, currentIndex + 1) +
                         Word::charAt(currentName, currentIndex) + Word::substring(currentName, currentIndex + 2);
        candidates.emplace_back(new TrieCandidate(swapped, currentIndex, currentPenalty + 1));
    }
    return candidates;
}

int TrieBasedSpellChecker::searchCandidates(const vector<Candidate *>& results, TrieCandidate* candidate) {
    for (int i = 0; i < results.size(); i++){
        if (results[i]->getName() == candidate->getName()){
            return i;
        }
    }
    return -1;
}
