//
// Created by Olcay Taner YILDIZ on 7.03.2023.
//

#include "TrieBasedSpellChecker.h"
#include "TrieCandidate.h"

/**
 * A constructor of TrieBasedSpellChecker class which takes a FsmMorphologicalAnalyzer, an NGram
 * and a SpellCheckerParameter as inputs. Then, calls its super class NGramSpellChecker with given inputs.
 *
 * @param fsm       FsmMorphologicalAnalyzer type input.
 * @param nGram     NGram type input.
 * @param _parameter SpellCheckerParameter type input.
 */
TrieBasedSpellChecker::TrieBasedSpellChecker(const FsmMorphologicalAnalyzer &fsm, NGram<string> *nGram,
                                             const SpellCheckerParameter &_parameter) : NGramSpellChecker(fsm, nGram,
                                                                                                          _parameter) {
    loadTrieDictionaries();
    prepareTrie();
}

/**
 * Another constructor of TrieBasedSpellChecker class which takes an FsmMorphologicalAnalyzer and
 * an NGram as inputs. Then, it calls its super class NGramSpellChecker with given inputs and
 * initializes the generatedWords and trie variables.
 *
 * @param fsm   FsmMorphologicalAnalyzer type input.
 * @param nGram NGram type input.
 */
TrieBasedSpellChecker::TrieBasedSpellChecker(const FsmMorphologicalAnalyzer &fsm, NGram<string> *nGram)
        : NGramSpellChecker(fsm, nGram) {
    loadTrieDictionaries();
    prepareTrie();
}

/**
 * {@inheritDoc}
 * This method also loads generated words from a file.
 */
void TrieBasedSpellChecker::loadTrieDictionaries() {
    ifstream inputStream = getInputStream("generated_words.txt");
    string line;
    while (inputStream.good()) {
        getline(inputStream, line);
        generatedWords.emplace_back(line);
    }
    inputStream.close();
}

/**
 * Populates a Trie data structure with a set of strings generated by the morphological analyzer.
 *
 * @see Trie
 * @see FsmMorphologicalAnalyzer#generateAllParses(TxtWord, int)
 */
void TrieBasedSpellChecker::prepareTrie() {
    trie = new SpellCheckerTrie();
    for (auto &word: generatedWords) {
        trie->insert(word);
    }
}

/**
 * The candidateList method takes a Word as an input and creates a candidates ArrayList by calling generateCandidateList
 * method with given word. Then, it loops i times where i ranges from 0 to size of candidates ArrayList and creates a
 * FsmParseList by calling morphologicalAnalysis with each item of candidates ArrayList. If the size of
 * FsmParseList is 0, it then removes the ith item.
 *
 * @param word Word input.
 * @param sentence Sentence for which candidate word list will be generated.
 * @return candidates ArrayList.
 */
vector<Candidate *> TrieBasedSpellChecker::candidateList(Word *word, Sentence *sentence) {
    TrieCandidate *candidate;
    deque<TrieCandidate *> candidates;
    vector<Candidate *> results;
    candidates.push_front(new TrieCandidate(word->getName(), -1, 0));
    string candidateName;
    double penaltyLimit = min(word->charCount() / 2.0, 3.0);
    while (!candidates.empty()) {
        candidate = candidates.front();
        candidateName = candidate->getName();
        if (trie->search(candidateName)) {
            int itemIndex = searchCandidates(results, candidate);
            if (itemIndex != -1 && ((TrieCandidate*) results[itemIndex])->getCurrentPenalty() <= candidate->getCurrentPenalty()) {
                candidates.pop_front();
            } else {
                results.emplace_back(candidate);
                candidates.pop_front();
            }
        } else {
            if (candidate->getCurrentPenalty() > penaltyLimit - 1 ||
                candidate->getCurrentIndex() >= Word::size(candidateName) - 1) {
                candidates.pop_front();
            } else {
                candidate = candidates.front();
                candidate->nextIndex();
                candidates.push_back(new TrieCandidate(candidate->getName(), candidate->getCurrentIndex(),
                                                       candidate->getCurrentPenalty()));
                candidate = candidates.front();
                vector<TrieCandidate *> newCandidates = generateTrieCandidates(candidate);
                candidates.pop_front();
                candidates.insert(candidates.end(), newCandidates.begin(), newCandidates.end());
            }
        }
    }
    return results;
}

/**
 * Generates a set of candidates based on a given TrieCandidate.
 * The generated candidates are created by applying a set of operations to
 * the input TrieCandidate. The possible operations are:
 * De-asciification: replacing certain ASCII characters with their non-ASCII counterparts.
 * Substitution: replacing a single character with another character.
 * Insertion: adding a single character to the string.
 * Deletion: removing a single character from the string.
 * Transposition: swapping the positions of two adjacent characters in the string.
 *
 * @param candidate the input TrieCandidate
 * @return a list of candidate strings, each contained in a TrieCandidate object
 */
vector<TrieCandidate *> TrieBasedSpellChecker::generateTrieCandidates(TrieCandidate *candidate) const {
    vector<TrieCandidate *> candidates;
    string currentName = candidate->getName();
    string deasciifiedWord;
    int currentIndex = candidate->getCurrentIndex();
    double currentPenalty = candidate->getCurrentPenalty();
    string letters;
    SpellCheckerTrieNode* currentNode = trie->getTrieNode(Word::substring(currentName, 0, currentIndex));
    if (currentNode == nullptr) {
        return candidates;
    }
    letters = currentNode->childrenToString();
    string ch = Word::charAt(currentName, currentIndex);
    string ch2;
    if (ch == "c") {
        ch2 = "ç";
    } else {
        if (ch == "g") {
            ch2 = "ğ";
        } else {
            if (ch == "i") {
                ch2 = "ı";
            } else {
                if (ch == "s") {
                    ch2 = "ş";
                } else {
                    if (ch == "o") {
                        ch2 = "ö";
                    } else {
                        if (ch == "u") {
                            ch2 = "ü";
                        }
                    }
                }
            }
        }
    }
    if (!ch2.empty()){
        deasciifiedWord =
                Word::substring(currentName, 0, currentIndex - 1) + ch2 + Word::substring(currentName, currentIndex + 1);
    } else {
        deasciifiedWord = currentName;
    }
    if (deasciifiedWord != currentName && trie->startsWith(Word::substring(deasciifiedWord, 0, currentIndex + 1))) {
        candidates.emplace_back(new TrieCandidate(deasciifiedWord, currentIndex, currentPenalty + 0.2));
    }
    for (int j = 0; j < Word::size(letters); j++) {
        string replaced = Word::substring(currentName, 0, currentIndex) + Word::charAt(letters, j) +
                          Word::substring(currentName, currentIndex + 1);
        candidates.emplace_back(new TrieCandidate(replaced, currentIndex, currentPenalty + 1));
        string added = Word::substring(currentName, 0, currentIndex) + Word::charAt(letters, j) +
                       Word::substring(currentName, currentIndex);
        candidates.emplace_back(new TrieCandidate(added, currentIndex, currentPenalty + 1));
        string addedLast = currentName + Word::charAt(letters, j);
        if (trie->startsWith(addedLast)) {
            candidates.emplace_back(new TrieCandidate(addedLast, currentIndex, currentPenalty + 1));
        }
    }
    string deleted = Word::substring(currentName, 0, currentIndex) + Word::substring(currentName, currentIndex + 1);
    if (deleted.length() > 1) {
        candidates.emplace_back(new TrieCandidate(deleted, currentIndex - 1, currentPenalty + 1));
    }
    if (currentIndex < Word::size(currentName) - 1 &&
        Word::charAt(currentName, currentIndex) != Word::charAt(currentName, currentIndex + 1) &&
        trie->startsWith(Word::substring(currentName, 0, currentIndex + 2))) {
        string swapped = Word::substring(currentName, 0, currentIndex) + Word::charAt(currentName, currentIndex + 1) +
                         Word::charAt(currentName, currentIndex) + Word::substring(currentName, currentIndex + 2);
        candidates.emplace_back(new TrieCandidate(swapped, currentIndex, currentPenalty + 1));
    }
    return candidates;
}

/**
 * Searches the intermediate results array for the given candidate. The search is done based on name of the candidate.
 * @param results Array to search for candidate
 * @param candidate Candidate to be searched.
 * @return Index of the candidate in the results array. If it does not exist, returns -1.
 */
int TrieBasedSpellChecker::searchCandidates(const vector<Candidate *>& results, TrieCandidate* candidate) {
    for (int i = 0; i < results.size(); i++){
        if (results[i]->getName() == candidate->getName()){
            return i;
        }
    }
    return -1;
}
